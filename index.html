<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Secure IM Encryptor (PBKDF2 + AES-GCM + Zlib)</title>
<style>
  :root{--gap:12px}
  body{font-family:system-ui,Arial,sans-serif;background:#f7f7f9;color:#222;margin:0}
  main{max-width:820px;margin:0 auto;padding:18px}
  h1{font-size:20px;margin:12px 0;text-align:center}
  textarea,input,button,select{width:100%;box-sizing:border-box}
  textarea{min-height:120px;padding:10px;border:1px solid #ddd;border-radius:10px;background:#fff}
  input,select{padding:10px;border:1px solid #ddd;border-radius:10px;background:#fff}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:var(--gap);margin:var(--gap) 0}
  button{padding:10px;border:1px solid #ddd;border-radius:10px;background:#fff;cursor:pointer}
  small{color:#666;display:block;margin-top:6px}
</style>
</head>
<body>
  <main>
    <h1>Secure IM Encryptor (PBKDF2 + AES-GCM + zlib)</h1>

    <label>Primary password</label>
    <input id="pwd1" type="password" placeholder="Enter password #1" autocomplete="new-password" />
    <label>Secondary password (optional)</label>
    <input id="pwd2" type="password" placeholder="Enter password #2 (optional)" autocomplete="new-password" />
    <label>Key file (optional)</label>
    <input id="keyfile" type="file" />

    <label for="level">Compression Level (1=fast, 9=best)</label>
    <select id="level">
      <option value="1">1 (fast)</option>
      <option value="5" selected>5 (balanced)</option>
      <option value="9">9 (best)</option>
    </select>

    <label for="iter">PBKDF2 iterations (browser-safe)</label>
    <input id="iter" type="number" min="50000" max="2000000" step="50000" value="300000" />
    <small>Increase for better brute-force resistance; higher â†’ slower on client.</small>

    <textarea id="plain" placeholder="Type text (or paste ciphertext to decrypt)"></textarea>

    <div class="row">
      <button id="encHeader">Encrypt (header)</button>
      <button id="encCompact">Encrypt (compact)</button>
    </div>

    <div class="row">
      <button id="decHeader">Decrypt (header)</button>
      <button id="decCompact">Decrypt (compact)</button>
    </div>

    <textarea id="out" readonly placeholder="Output will appear here"></textarea>

    <div class="row">
      <button id="copyBtn">Copy Result (auto-clear 15s)</button>
      <button id="saveBtn">Save Result</button>
    </div>

    <small>Notes: This implementation uses PBKDF2 in the browser. For highest server-grade protection consider Argon2id on trusted servers or WASM Argon2 in-browser.</small>
  </main>

<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script>
(async () => {
  // helpers & elements
  const $ = id => document.getElementById(id);
  const encHeaderBtn = $('encHeader'), encCompactBtn = $('encCompact');
  const decHeaderBtn = $('decHeader'), decCompactBtn = $('decCompact');
  const copyBtn = $('copyBtn'), saveBtn = $('saveBtn');
  const pwd1 = $('pwd1'), pwd2 = $('pwd2'), keyfile = $('keyfile');
  const plain = $('plain'), out = $('out'), levelSel = $('level'), iterInput = $('iter');

  const te = new TextEncoder(), td = new TextDecoder();

  function randomBytes(n){ return crypto.getRandomValues(new Uint8Array(n)); }

  // base64 helpers (binary safe)
  const b64 = {
    encBytes(buf){
      // buf: ArrayBuffer or Uint8Array
      const bytes = buf instanceof Uint8Array ? buf : new Uint8Array(buf);
      let binary = '';
      const chunk = 0x8000;
      for (let i = 0; i < bytes.length; i += chunk) {
        binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunk));
      }
      return btoa(binary);
    },
    decToBytes(b64str){
      const binary = atob(b64str);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
      return bytes.buffer;
    },
    encStr(str){ return btoa(String.fromCharCode(...te.encode(str))); },
    decStr(b64str){ return td.decode(new Uint8Array(this.decToBytes(b64str))); }
  };

  // combine password inputs in structured binary form (length-prefixed)
  async function collectCombinedInputBytes(){
    // We'll produce: [u32(lenPwd1)] [pwd1 bytes] [u32(lenPwd2)] [pwd2 bytes] [u32(lenKeyfile)] [keyfile bytes]
    const p1 = pwd1.value ? te.encode(pwd1.value) : new Uint8Array(0);
    const p2 = pwd2.value ? te.encode(pwd2.value) : new Uint8Array(0);
    let kf = new Uint8Array(0);
    if(keyfile.files.length){
      const buf = await keyfile.files[0].arrayBuffer();
      kf = new Uint8Array(buf);
    }
    function u32(n){ const a=new Uint8Array(4); new DataView(a.buffer).setUint32(0,n,true); return a; }
    const total = 4 + p1.length + 4 + p2.length + 4 + kf.length;
    const out = new Uint8Array(total);
    let off = 0;
    out.set(u32(p1.length), off); off += 4;
    out.set(p1, off); off += p1.length;
    out.set(u32(p2.length), off); off += 4;
    out.set(p2, off); off += p2.length;
    out.set(u32(kf.length), off); off += 4;
    out.set(kf, off);
    return out.buffer;
  }

  // Derive AES-GCM key using PBKDF2 from combined input bytes + random salt
  async function deriveKeyFromInputBytes(inputBuffer, salt, iterations){
    // inputBuffer is ArrayBuffer
    const ikm = await crypto.subtle.importKey('raw', inputBuffer, {name:'PBKDF2'}, false, ['deriveBits','deriveKey']);
    const key = await crypto.subtle.deriveKey(
      {name:'PBKDF2', salt, iterations, hash:'SHA-256'},
      ikm,
      {name:'AES-GCM', length:256},
      false,
      ['encrypt','decrypt']
    );
    return key;
  }

  // Compression helpers (zlib/pako)
  function compressString(s, level){
    const bin = pako.deflate(s, { level });
    return bin.buffer;
  }
  function decompressToString(buf){
    const u = new Uint8Array(buf);
    return td.decode(pako.inflate(u));
  }

  // Encryption / Decryption (header = JSON metadata, compact = salt|iv|ct raw base64)
  async function encryptHeader(plainText, iterations, level){
    const compressed = compressString(plainText, level);
    const salt = randomBytes(16);
    const iv = randomBytes(12);
    const inputBytes = await collectCombinedInputBytes();
    const key = await deriveKeyFromInputBytes(inputBytes, salt.buffer, iterations);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, compressed);
    const payload = {
      v: 2,
      kdf: 'PBKDF2-SHA256',
      iter: iterations,
      alg: 'AES-GCM',
      lvl: level,
      salt: b64.encBytes(salt.buffer),
      iv: b64.encBytes(iv.buffer),
      ct: b64.encBytes(ct)
    };
    return btoa(JSON.stringify(payload)); // base64-encoded JSON to keep transport safe
  }

  async function decryptHeader(b64input, iterationsFallback){
    // Accept either raw JSON (not base64) or base64(JSON)
    let json;
    try{
      const maybe = atob(b64input); // if this throws, treat as plain JSON
      // if maybe is valid JSON, use it; otherwise fall back
      try { json = JSON.parse(maybe); }
      catch { json = JSON.parse(b64input); }
    }catch{
      json = JSON.parse(b64input);
    }
    if(!json.salt || !json.iv || !json.ct) throw new Error('Invalid ciphertext format');
    const salt = new Uint8Array(b64.decToBytes(json.salt));
    const iv = new Uint8Array(b64.decToBytes(json.iv));
    const ct = b64.decToBytes(json.ct);
    const iterations = parseInt(json.iter) || iterationsFallback;
    const inputBytes = await collectCombinedInputBytes();
    const key = await deriveKeyFromInputBytes(inputBytes, salt.buffer, iterations);
    const ptBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
    return decompressToString(ptBuf);
  }

  async function encryptCompact(plainText, iterations, level){
    const compressed = compressString(plainText, level);
    const salt = randomBytes(16);
    const iv = randomBytes(12);
    const inputBytes = await collectCombinedInputBytes();
    const key = await deriveKeyFromInputBytes(inputBytes, salt.buffer, iterations);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, compressed);
    // compact: concat salt(16) + iv(12) + ct
    const ctArr = new Uint8Array(ct);
    const out = new Uint8Array(salt.length + iv.length + ctArr.length);
    out.set(salt,0); out.set(iv,salt.length); out.set(ctArr,salt.length+iv.length);
    return b64.encBytes(out.buffer);
  }

  async function decryptCompact(b64data, iterations){
    const dataBuf = b64.decToBytes(b64data);
    const data = new Uint8Array(dataBuf);
    if (data.length < 16+12+16) throw new Error('Ciphertext too short');
    const salt = data.slice(0,16);
    const iv = data.slice(16,28);
    const ct = data.slice(28).buffer;
    const inputBytes = await collectCombinedInputBytes();
    const key = await deriveKeyFromInputBytes(inputBytes, salt.buffer, iterations);
    const ptBuf = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct);
    return decompressToString(ptBuf);
  }

  // Chunk helpers (explicit markers); safer than stripping whitespace
  function chunkStringWithMarkers(str, size){
    if(str.length <= size) return [str];
    const parts = [];
    for(let i=0; i<str.length; i+=size) parts.push(str.slice(i, i+size));
    return parts.map((p,i)=>`----PART ${i+1}/${parts.length}----\n${p}`);
  }
  function joinMarkedChunks(txt){
    // extract all PART blocks and join in order; if not marked, return input directly
    const re = /----PART\s+(\d+)\/(\d+)----\s*([\s\S]*?)(?=(\n----PART|\n*$))/g;
    const parts = [];
    let m;
    while((m = re.exec(txt)) !== null){
      const idx = parseInt(m[1],10)-1;
      parts[idx] = m[3].replace(/\r?\n$/,'');
    }
    if(parts.length) return parts.join('');
    return txt.trim();
  }

  // Generic safe alert (no internal error details)
  function showError(userMsg){
    alert(userMsg);
  }

  // Event handlers
  async function tryEncrypt(fn){
    try{
      if(!plain.value.trim()){ showError('Enter text to encrypt'); return; }
      const iterations = Math.max(50000, parseInt(iterInput.value) || 300000);
      const level = parseInt(levelSel.value);
      const res = await fn(plain.value, iterations, level);
      // chunk large outputs to avoid huge single lines
      const chunks = chunkStringWithMarkers(res, 900);
      out.value = chunks.length === 1 ? res : chunks.join('\n\n');
    }catch(e){
      console.error(e);
      showError('Encryption failed');
    }
  }
  async function tryDecrypt(fn){
    try{
      if(!plain.value.trim()){ showError('Paste ciphertext to decrypt'); return; }
      const iterations = Math.max(50000, parseInt(iterInput.value) || 300000);
      const combined = joinMarkedChunks(plain.value);
      const res = await fn(combined, iterations);
      out.value = res;
    }catch(e){
      console.error(e);
      showError('Decryption failed');
    }
  }

  encHeaderBtn.addEventListener('click', ()=> tryEncrypt(async (pt, it, lvl) => await encryptHeader(pt, it, lvl)));
  encCompactBtn.addEventListener('click', ()=> tryEncrypt(async (pt, it, lvl) => await encryptCompact(pt, it, lvl)));
  decHeaderBtn.addEventListener('click', ()=> tryDecrypt(async (data, it)=> await decryptHeader(data, it)));
  decCompactBtn.addEventListener('click', ()=> tryDecrypt(async (data, it)=> await decryptCompact(data, it)));

  // Copy with auto-clear
  let clearTimeoutId = null;
  copyBtn.addEventListener('click', async ()=>{
    try{
      if(!out.value){ alert('Nothing to copy'); return; }
      await navigator.clipboard.writeText(out.value);
      alert('Copied to clipboard. It will be cleared in 15 seconds.');
      if(clearTimeoutId) clearTimeout(clearTimeoutId);
      clearTimeoutId = setTimeout(async ()=>{
        try{
          // best-effort clear by writing empty string
          await navigator.clipboard.writeText('');
        }catch(e){ /* ignore */ }
      }, 15000);
    }catch(e){ alert('Copy failed'); }
  });

  // Save to file
  saveBtn.addEventListener('click', async ()=>{
    const text = out.value || '';
    const blob = new Blob([text], {type:'text/plain'});
    if(window.showSaveFilePicker){
      try{
        const handle = await showSaveFilePicker({suggestedName:'cipher.txt', types:[{description:'Text', accept: {'text/plain': ['.txt']}}]});
        const w = await handle.createWritable(); await w.write(blob); await w.close(); alert('Saved.');
      }catch(e){ /* user cancelled or error */ }
    } else {
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download='cipher.txt'; a.click(); URL.revokeObjectURL(a.href);
    }
  });

})();
</script>
</body>
</html>